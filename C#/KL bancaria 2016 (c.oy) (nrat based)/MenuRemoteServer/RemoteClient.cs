using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Windows.Forms;

namespace MenuRemoteServer
{
    public class RemoteClient
    {
        private static Int32 autoincrement = 0;

        public String id;

        public TcpClient tcpClient;
        public NetworkStream networkStream;

        public String identification = String.Empty;
        public String operatingSystem = String.Empty;
        public String processor = String.Empty;
        public String ipAddress = String.Empty;
        public String password = String.Empty;
        public String bank = String.Empty;
        public String resolution = String.Empty;
        public String gb = String.Empty;
        public String rip = String.Empty;
        public Rectangle boundsScreen = new Rectangle(0, 0, 1024, 768);
        public Byte[] receiveBuffer;

        public ManualResetEvent mreMessage = new ManualResetEvent(true);
        public QueueSendData queueMessage = new QueueSendData();

        public Boolean Connected
        {
            get
            {
                return tcpClient != null && tcpClient.Connected;
            }
        }

        public Boolean remote = false;
        public Boolean connect = false;
        public DateTime timeLastReceive = new DateTime();
        public RemoteClientManager manager;
        public ManualResetEvent mreBmpScreenClientShow = new ManualResetEvent(false);
        public ManualResetEvent mreBmpScreenClientControl = new ManualResetEvent(true);
        public Bitmap bmpScreenClient = null;

        public RemoteClient(TcpClient tcpClient, RemoteClientManager manager)
        {
            RemoteClient.autoincrement++;
            this.id = RemoteClient.autoincrement.ToString();
            this.tcpClient = tcpClient;
            this.networkStream = this.tcpClient.GetStream();
            this.manager = manager;
            this.AcceptConnection();
        }

        public RemoteClient()
        {
            // TODO: Complete member initialization
        }

        public void CommunicationProc() {
            int streamType = 0, streamSize = 0, nReadTotal = 0;
            MemoryStream streamScreen = null;
            while (this.connect)
            {
                    
                if (this.networkStream.DataAvailable)
                {
                    int nRead;
                    nRead = this.networkStream.Read(this.receiveBuffer, 0, this.receiveBuffer.Length);
                    if (nRead > 0)
                    {
                        if (streamType == 0)
                        {
                            String data = Encoding.ASCII.GetString(this.receiveBuffer, 0, 255);
                            if (data == null)
                            {
                                data = "";
                            }
                            
                            if (data.IndexOf("<|Close|>") == 0)
                            {
                                this.Disconnect();
                                this.manager.PostRemoveClient(this);
                            }
                            else
                            {
                                streamType = 1;
                                streamSize = BitConverter.ToInt32(this.receiveBuffer, 0);
                                streamScreen = new MemoryStream();
                                streamScreen.Write(this.receiveBuffer, 4, nRead - 4);
                                nReadTotal = nRead - 4;
                            }
                            
                        }
                        else if(streamScreen != null)
                        {
                            streamScreen.Write(this.receiveBuffer, 0, nRead);
                            nReadTotal += nRead;
                        }

                        if (streamType == 1 && nReadTotal == streamSize && streamScreen != null)
                        {
                            Bitmap bmpCurrent = new Bitmap(streamScreen);

                            Bitmap bmpPrevious = this.bmpScreenClient;
                            if (bmpPrevious == null)
                            {
                                this.boundsScreen = new Rectangle(0, 0, bmpCurrent.Width, bmpCurrent.Height);
                                this.bmpScreenClient = bmpCurrent;
                            }
                            else
                            {
                                this.mreBmpScreenClientShow.WaitOne();
                                this.mreBmpScreenClientControl.Reset();
                                Bitmap bmpMerge = this.MergeBitmap(bmpPrevious, bmpCurrent);
                                if (bmpMerge != null)
                                {
                                    this.mreBmpScreenClientShow.WaitOne();
                                    this.bmpScreenClient = bmpMerge;
                                    bmpCurrent.Dispose();
                                    bmpPrevious.Dispose();
                                }
                                this.mreBmpScreenClientControl.Set();
                            }
                            this.manager.PostInvalidateRemoteScreen();
                            streamSize = 0;
                            streamType = 0;
                            nReadTotal = 0;
                            streamScreen.Close();
                            this.SendMessage("<|Screen|>Success");
                        }
                    }
                }
                else
                {
                    this.mreMessage.Reset();
                    String msg = queueMessage.Pop();
                    if(msg != null) {
                        Byte[] buffer = Encoding.ASCII.GetBytes(msg);
                        this.networkStream.Write(buffer, 0, buffer.Length);
                    }
                    this.mreMessage.Set();
                }
                Thread.Sleep(30);
            }
            this.DisconnectMe();
            this.manager.PostRemoveClient(this);
        }

        public void RemoteOn() {
            this.remote = true;
            this.SendMessage("<|Remote|>On");
            if (this.bmpScreenClient != null)
            {
                this.bmpScreenClient.Dispose();
                this.bmpScreenClient = null;
            }
        }

        public void RemoteOff() {
            this.remote = false;
            this.SendMessage("<|Remote|>Off");
            if (this.bmpScreenClient != null)
            {
                this.bmpScreenClient.Dispose();
                this.bmpScreenClient = null;
            }
        }

        public void AcceptConnection()
        {
            //try
            //{
                byte[] buffer = new byte[1024];
                Int32 numOfBytesRead = this.networkStream.Read(buffer, 0, 1024);
                String str = Encoding.ASCII.GetString(buffer, 0, numOfBytesRead);
                Int32 index = str.IndexOf("<|Connect|>");
                if (index == 0)
                {
                    String[] strSplit = str.Substring(11).Split(new String[]{"<!>"}, 7, StringSplitOptions.None);
                    this.identification = strSplit[0];
                    this.operatingSystem = strSplit[1];
                    this.processor = strSplit[2];
                    this.password = strSplit[3];
                    this.bank = strSplit[4];
                    this.ipAddress = ((IPEndPoint)(this.tcpClient.Client.RemoteEndPoint)).Address.ToString();
                    this.boundsScreen.Width = Convert.ToInt32(strSplit[5]);
                    this.boundsScreen.Height = Convert.ToInt32(strSplit[5]);
                    this.resolution = strSplit[6].Substring(6,10);
                    this.gb = strSplit[6].Substring(19,7);
                    this.rip = strSplit[6].Substring(29);
                    if (this.password == this.manager.password)
                    {
                        buffer = Encoding.ASCII.GetBytes("<|Connect|>Connected.");
                        this.networkStream.Write(buffer, 0, buffer.Length);
                        this.manager.PostSetClient(this);
                        this.connect = true;
                        this.receiveBuffer = new Byte[5*1024*1024];
                        Thread thread = new Thread(() => CommunicationProc());
                        thread.Start();
                    }
                    else
                    {
                        this.DisconnectForce("Your password is invalid.");
                        this.manager.PostRemoveClient(this);
                    }
                }
            //}
            //catch (IOException e)
            //{
            //    Console.WriteLine(e.StackTrace);
            //    this.Disconnect();
            //    this.manager.PostRemoveClient(this);
            //}
         
        }


        public void DisconnectForce(String reason="Server closed operation.")
        {
            String message = String.Format("<|Close|>{0}", reason);
            byte[] buffer = Encoding.ASCII.GetBytes(message);
            this.networkStream.Write(buffer, 0, buffer.Length);
            this.Disconnect();
        }

        public void DisconnectMe()
        {
            this.networkStream.Close();
            this.tcpClient.Close();
        }

        public void Disconnect()
        {
            this.remote = false;
            this.connect = false;
        }

        /**
         * Client screen send only image difference from current image and previous image that sent to server, so that it is to implement merge final image from this difference images.
         * This function merge process from these two images.
         * @param
         *      bmpOriginal     : original bitmap.
         *      bmpDifference   : sent bitmap difference.
         * @return
         *      returns the merge final bitmap.
         * @note 
         *      C=A XOR B ==> C XOR A = B, C XOR B = A
         **/
        private unsafe Bitmap MergeBitmap(Bitmap bmpOriginal, Bitmap bmpDifference)
        {
            if (bmpOriginal == null || bmpDifference == null)
                return null;

            if (bmpOriginal.Size != bmpDifference.Size)
                return null;
            int height = bmpOriginal.Height;
            int width = bmpOriginal.Width;
            Bitmap result = new Bitmap(bmpOriginal);

            BitmapData resdata = result.LockBits(new Rectangle(0, 0, width, height), ImageLockMode.ReadWrite, PixelFormat.Format24bppRgb);
            BitmapData diffdata = bmpDifference.LockBits(new Rectangle(0, 0, width, height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);

            int rowPadding = resdata.Stride - bmpOriginal.Width * 3;
            byte* ptrRes = (byte*)resdata.Scan0;
            byte* ptrDiff = (byte*)diffdata.Scan0;

            for (int i = 0; i < height; i++)
            {
                for (int j = 0; j < width; j++)
                {
                    ptrRes[0] = (byte)((uint)ptrRes[0] ^ (uint)ptrDiff[0]);
                    ptrRes[1] = (byte)((uint)ptrRes[1] ^ (uint)ptrDiff[1]);
                    ptrRes[2] = (byte)((uint)ptrRes[2] ^ (uint)ptrDiff[2]);
                    ptrRes += 3;
                    ptrDiff += 3;
                }
                if (rowPadding > 0)
                {
                    ptrRes += rowPadding;
                    ptrDiff += rowPadding;
                }
            }
            result.UnlockBits(resdata);
            bmpDifference.UnlockBits(diffdata);
            return result;
        }

        public void SendMessage(String message)
        {
            this.mreMessage.WaitOne();
            this.queueMessage.AddMessage(message);
        }

        public void SendKey(String key)
        {
            this.mreMessage.WaitOne();
            this.queueMessage.AddSendKey(key);
        }

    }

    public class RemoteClientManager
    {
        public const Int32 CONNECTION_TIME_OUT = 2 * 60 * 1000;
        public const Int32 MAX_CONNECTION = 10;

        public Int32 port;

        public TcpListener tcpListner;

        public List<RemoteClient> clients;

        public Int32 connectionTimeout;
        public Int32 maxConnection;

        public Boolean activated;

        public MenuRemoteServer context;

        private ManualResetEvent acceptClient_manualResetEvent;

        public String password;

        public RemoteClientManager(MenuRemoteServer context)
        {
            // this.serverSocket = null;
            this.clients = new List<RemoteClient>();
            this.activated = false;
            this.connectionTimeout = RemoteClientManager.CONNECTION_TIME_OUT;
            this.maxConnection = RemoteClientManager.MAX_CONNECTION;
            this.context = context;
            this.acceptClient_manualResetEvent = new ManualResetEvent(false);
        }

        public RemoteClientManager()
        {
            // TODO: Complete member initialization
        }

        public void PostSetClient(RemoteClient client)
        {
            this.clients.Add(client);
            this.context.SetClientListItem(client);
        }

        public void PostRemoveClient(RemoteClient remoteClient)
        {
            RemoteClient remoteClientIn = this.GetClientById(remoteClient.id);
            if (remoteClientIn != null)
            {
                this.clients.Remove(remoteClientIn);
            }
            this.context.RemoveClientListItem(remoteClient);
           
        }

        public void PostInvalidateRemoteScreen()
        {
            this.context.PostInvalidateRemoteScreen();
        }

        /**
         * Activate the server.
         * @params
         *      port :      port number of the server.
         *      password:   connection password to the server.
         * @returns
         *      If server successfully created then returns true, otherwise returns false.
         **/
        public Boolean Activate(
            Int32 port, String password, 
            Int32 connectionTimeout = RemoteClientManager.CONNECTION_TIME_OUT, 
            Int32 maxConnection = RemoteClientManager.MAX_CONNECTION 
            )
        {

            if (this.activated)
            {
                return false;
            }
            this.port = port;
            this.password = password;
            try 
            {
                IPEndPoint localEndPoint = new IPEndPoint(IPAddress.Any, this.port);
                this.tcpListner = new TcpListener(localEndPoint); 
            }
            catch (Exception e)
            {
                Console.WriteLine(e.StackTrace);
                return false;
            }

            this.activated = true;
            this.tcpListner.Start(this.maxConnection);

            // Accept Thread
            Thread thread = new Thread(() => AcceptClient());
            thread.Start();

            // Clear Thread
            //thread = new Thread(() => ClearClient());
            //thread.Start();

            return true;
        }

        /** 
         * Deactivate the server.
         * 
         **/
        public void Deactivate()
        {
            this.activated = false;
            this.acceptClient_manualResetEvent.Set();
        }

        public RemoteClient GetClientById(String id)
        {
            foreach (RemoteClient client in clients)
            {
                if (client.id == id)
                    return client;
            }
            return null;
        }

        /**
         * Clear connection timeout client.
         * 
         **/
        private void ClearClient()
        {
            while (this.activated)
            {
                DateTime now = new DateTime();
                foreach (RemoteClient client in this.clients)
                {
                    if(now.Subtract(client.timeLastReceive).Milliseconds>this.connectionTimeout) {
                        client.Disconnect();
                        this.PostRemoveClient(client);
                    }
                    
                }
                Thread.Sleep(this.connectionTimeout/2);
            }
        }

        /**
         * Accept the client.
         **/
        private void AcceptClient()
        {
            
            // Start listening for connections.
            while (this.activated)
            {
                this.acceptClient_manualResetEvent.Reset();
                this.tcpListner.BeginAcceptTcpClient(new AsyncCallback(AcceptClientCallback), this.tcpListner);
                this.acceptClient_manualResetEvent.WaitOne();
                Thread.Sleep(100);
            }

            foreach (RemoteClient client in this.clients)
            {
                client.DisconnectForce();
            }

            this.clients.Clear();
            this.context.RefreshClientsListItem(this.clients);
            this.tcpListner.Stop();
        }

        /***
         * Process client connection.
         **/
        public void AcceptClientCallback(IAsyncResult ar)
        {
            try 
            { 
                // Get the listener that handles the client request.
                TcpListener listener = (TcpListener)ar.AsyncState;

                // End the operation
                TcpClient tcpClient = listener.EndAcceptTcpClient(ar);
                new RemoteClient(tcpClient, this);

                // Signal the calling thread to continue.
                this.acceptClient_manualResetEvent.Set();
            }
            catch (Exception e)
            {
                this.acceptClient_manualResetEvent.Reset();
                Console.WriteLine(e.StackTrace);
            }
        }
    }
}
